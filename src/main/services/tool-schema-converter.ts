/**
 * Converts internal ToolDefinition[] to native function calling formats
 * for OpenAI and Anthropic APIs.
 *
 * This enables native tool use instead of the legacy ```tool code block approach.
 */

import type { ToolDefinition } from '../../shared/types/tools';

// ─── OpenAI Format ───

export interface OpenAITool {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: {
      type: 'object';
      properties: Record<string, OpenAIJsonSchemaProperty>;
      required?: string[];
    };
    strict?: boolean;
  };
}

interface OpenAIJsonSchemaProperty {
  type: string;
  description?: string;
  items?: { type: string };
}

// ─── Anthropic Format ───

export interface AnthropicTool {
  name: string;
  description: string;
  input_schema: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
  };
}

// ─── Native Tool Call (provider-agnostic) ───

export interface NativeToolCall {
  id: string;
  name: string;
  arguments: Record<string, any>;
}

export interface NativeToolStreamResult {
  /** Text content generated by the model (may be empty if only tool calls). */
  text: string;
  /** Tool calls requested by the model. Empty if the model just wants to talk. */
  toolCalls: NativeToolCall[];
  /** Internal messages state — pass to continueWithToolResults for the next turn. */
  _messages: any[];
}

// ─── Converters ───

/**
 * Convert internal parameter type string to JSON Schema type.
 * Handles: string, number, boolean, string[], number[], object
 */
function convertParamType(internalType: string): OpenAIJsonSchemaProperty {
  if (internalType.endsWith('[]')) {
    const itemType = internalType.slice(0, -2);
    return { type: 'array', items: { type: itemType } };
  }
  // Bare 'array' without item type — default to object items
  if (internalType === 'array') {
    return { type: 'array', items: { type: 'object' } };
  }
  return { type: internalType };
}

/**
 * Convert ToolDefinition[] to OpenAI function calling format.
 *
 * @example
 * const tools = toOpenAITools(toolsService.getDefinitions());
 * const response = await openai.chat.completions.create({ ..., tools });
 */
export function toOpenAITools(definitions: ToolDefinition[]): OpenAITool[] {
  return definitions.map((def) => {
    const properties: Record<string, OpenAIJsonSchemaProperty> = {};
    const required: string[] = [];

    for (const [name, param] of Object.entries(def.parameters)) {
      properties[name] = {
        ...convertParamType(param.type),
        description: param.description,
      };
      if (param.required) {
        required.push(name);
      }
    }

    return {
      type: 'function' as const,
      function: {
        name: def.name,
        description: def.description,
        parameters: {
          type: 'object' as const,
          properties,
          ...(required.length > 0 ? { required } : {}),
        },
      },
    };
  });
}

/**
 * Convert ToolDefinition[] to Anthropic tool format.
 *
 * @example
 * const tools = toAnthropicTools(toolsService.getDefinitions());
 * const response = await anthropic.messages.create({ ..., tools });
 */
export function toAnthropicTools(definitions: ToolDefinition[]): AnthropicTool[] {
  return definitions.map((def) => {
    const properties: Record<string, any> = {};
    const required: string[] = [];

    for (const [name, param] of Object.entries(def.parameters)) {
      properties[name] = {
        ...convertParamType(param.type),
        description: param.description,
      };
      if (param.required) {
        required.push(name);
      }
    }

    return {
      name: def.name,
      description: def.description,
      input_schema: {
        type: 'object' as const,
        properties,
        ...(required.length > 0 ? { required } : {}),
      },
    };
  });
}
